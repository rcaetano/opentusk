#!/usr/bin/env bash
set -euo pipefail

# ─── Resolve repo root ─────────────────────────────────────────────────────
MUSTANGCLAW_ROOT="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "${BASH_SOURCE[0]}")")" && pwd)"
source "$MUSTANGCLAW_ROOT/scripts/config.sh"

# ─── Help ───────────────────────────────────────────────────────────────────
usage() {
    cat <<EOF
Usage: mustangclaw <command> [options]

Commands:
  init      Configure MustangClaw (interactive wizard) [--reset]
  build     Clone repo & build Docker image          [--no-pull] [--browser] [--apt PKG]
  run       Run gateway locally                      [--rebuild] [--logs] [--stop]
  tui       Launch interactive TUI client
  setup     Run OpenClaw interactive setup wizard
  deploy    Create & provision DO droplet             [--dry-run] [--force]
  destroy   Tear down DO droplet                      [--force]
  sync      Sync ~/.mustangclaw config               [--target local|remote] [--ip IP] [--dry-run]
  upgrade   Upgrade MustangClaw in-place             [--target local|remote] [--ip IP] [--rollback]
  ssh       SSH into droplet                          [--tunnel] [--ip IP]
  sandbox   Build sandbox images for agent isolation    [--browser] [--common] [--all]
  token     Show the current gateway token
  dashboard Open OpenClaw Control in the browser (with token)
  poseidon  Open Poseidon dashboard in the browser
  save      Export Docker image to archive              [--output PATH] [--no-compress]
  load      Import Docker image from archive           <FILE>
  restart   Restart the gateway container
  logs      Tail gateway container logs                [--lines N]
  exec      Run an OpenClaw CLI command in the gateway       e.g. exec health
  docker    Open a shell inside the gateway container
  rotate-tokens  Rotate all device tokens with full scope set (2026.2.19 fix)
  audit     Full sanity check of the setup                 [--remote] [--fix]
  status    Show local container & remote droplet status  [--health]

Run 'mustangclaw <command> --help' for details on a specific command.
EOF
    exit 0
}

# ─── Docker CLI helper ────────────────────────────────────────────────────
# Run an openclaw CLI command in a container attached to the gateway's network.
# Falls back to the default compose network if the gateway isn't running.
run_cli() {
    require_cmd docker
    cd "$PROJECT_ROOT"
    if [[ ! -f "$MUSTANGCLAW_DIR/.env" ]]; then
        log_error "No .env found. Run 'mustangclaw run' first to start the gateway."
        exit 1
    fi
    source "$MUSTANGCLAW_DIR/.env"

    # Prefer token from openclaw.json (source of truth after 'mustangclaw setup')
    local json_token
    json_token=$(read_json_token)
    if [[ -n "$json_token" ]]; then
        OPENCLAW_GATEWAY_TOKEN="$json_token"
    fi

    local network_flag=()
    local gw_container
    gw_container=$(get_running_gateway)
    if [[ -n "$gw_container" ]]; then
        network_flag=(--network "container:$gw_container")
    fi
    docker run --rm -it \
        ${network_flag[@]+"${network_flag[@]}"} \
        -e HOME=/home/node \
        -e TERM=xterm-256color \
        -e OPENCLAW_GATEWAY_TOKEN="${OPENCLAW_GATEWAY_TOKEN}" \
        -v "${OPENCLAW_CONFIG_DIR}:/home/node/.openclaw" \
        -v "${OPENCLAW_WORKSPACE_DIR}:/home/node/.openclaw/workspace" \
        "$MUSTANGCLAW_IMAGE" \
        node dist/index.js "$@"
}

# ─── Sync gateway token from openclaw.json → .env ────────────────────────
# Returns 0 if token was updated, 1 if no change needed.
sync_gateway_token() {
    local env_file="$MUSTANGCLAW_DIR/.env"
    [[ -f "$MUSTANGCLAW_CONFIG_DIR/openclaw.json" && -f "$env_file" ]] || return 1

    local new_token old_token
    new_token=$(read_json_token)
    old_token=$(grep '^OPENCLAW_GATEWAY_TOKEN=' "$env_file" | cut -d= -f2-)
    [[ -n "$new_token" && "$new_token" != "$old_token" ]] || return 1

    # Update .env with the token from openclaw.json
    local tmpfile
    tmpfile=$(mktemp)
    awk -v tok="$new_token" \
        '/^OPENCLAW_GATEWAY_TOKEN=/{$0="OPENCLAW_GATEWAY_TOKEN="tok}{print}' \
        "$env_file" > "$tmpfile" && mv "$tmpfile" "$env_file"
    return 0
}

# ─── Setup helpers ────────────────────────────────────────────────────────

# Poll the gateway HTTP endpoint until it responds or timeout expires.
# Usage: wait_gateway_healthy [timeout_seconds]
wait_gateway_healthy() {
    local timeout="${1:-30}"
    local i=0
    while [[ $i -lt $timeout ]]; do
        if curl -sf -o /dev/null --max-time 2 "http://localhost:${GATEWAY_PORT}"; then
            return 0
        fi
        sleep 1
        i=$((i + 1))
    done
    return 1
}

# Pre-flight checks before launching the setup wizard.
setup_preflight() {
    local checks_pass=0 checks_fail=0
    printf "\n${_CYAN}── Pre-flight Checks ──${_NC}\n"

    # 1. Docker installed
    if command -v docker &>/dev/null; then
        printf "${_GREEN}  [OK]${_NC} Docker installed\n"
        checks_pass=$((checks_pass + 1))
    else
        printf "${_RED}  [FAIL]${_NC} Docker is not installed\n"
        checks_fail=$((checks_fail + 1))
        log_error "Install Docker before running setup."
        return 1
    fi

    # 2. Docker image exists
    if [[ -n "$(docker images "$MUSTANGCLAW_IMAGE" -q 2>/dev/null)" ]]; then
        printf "${_GREEN}  [OK]${_NC} Docker image '$MUSTANGCLAW_IMAGE' exists\n"
        checks_pass=$((checks_pass + 1))
    else
        printf "${_RED}  [FAIL]${_NC} Docker image '$MUSTANGCLAW_IMAGE' not found\n"
        checks_fail=$((checks_fail + 1))
        log_error "Run 'mustangclaw build' first to build the Docker image."
        return 1
    fi

    # 3. .env file exists (gateway has been started at least once)
    if [[ -f "$MUSTANGCLAW_DIR/.env" ]]; then
        printf "${_GREEN}  [OK]${_NC} Gateway .env file exists\n"
        checks_pass=$((checks_pass + 1))
    else
        printf "${_RED}  [FAIL]${_NC} No .env file found at $MUSTANGCLAW_DIR/.env\n"
        checks_fail=$((checks_fail + 1))
        log_error "Run 'mustangclaw run' first to start the gateway."
        return 1
    fi

    # 4. Gateway container is running
    local gw_container
    gw_container=$(get_running_gateway)
    if [[ -n "$gw_container" ]]; then
        printf "${_GREEN}  [OK]${_NC} Gateway container is running ($gw_container)\n"
        checks_pass=$((checks_pass + 1))
    else
        printf "${_RED}  [FAIL]${_NC} Gateway container is not running\n"
        checks_fail=$((checks_fail + 1))
        log_error "Start the gateway with 'mustangclaw run' before running setup."
        return 1
    fi

    # 5. Gateway is healthy (HTTP responding)
    printf "${_CYAN}  [..]${_NC} Waiting for gateway to be healthy...\r"
    if wait_gateway_healthy 30; then
        printf "${_GREEN}  [OK]${_NC} Gateway is responding on port $GATEWAY_PORT\n"
        checks_pass=$((checks_pass + 1))
    else
        printf "${_RED}  [FAIL]${_NC} Gateway not responding on port $GATEWAY_PORT after 30s\n"
        checks_fail=$((checks_fail + 1))
        log_error "Gateway is running but not responding. Check 'mustangclaw logs' for errors."
        return 1
    fi

    # 6. Backup openclaw.json
    local json_file="$MUSTANGCLAW_CONFIG_DIR/openclaw.json"
    if [[ -f "$json_file" ]]; then
        local backup_file="${json_file}.bak"
        cp "$json_file" "$backup_file"
        printf "${_GREEN}  [OK]${_NC} Config backed up to $backup_file\n"
        checks_pass=$((checks_pass + 1))
    else
        printf "${_YELLOW}  [--]${_NC} No openclaw.json to back up (first-time setup)\n"
    fi

    printf "${_GREEN}All pre-flight checks passed ($checks_pass/$checks_pass).${_NC}\n\n"
    return 0
}

# Post-setup validation after the wizard and token sync.
setup_validate() {
    local pass=0 warn_count=0 fail_count=0
    printf "\n${_CYAN}── Post-setup Validation ──${_NC}\n"

    local json_file="$MUSTANGCLAW_CONFIG_DIR/openclaw.json"
    local env_file="$MUSTANGCLAW_DIR/.env"

    # 1. JSON valid
    if [[ -f "$json_file" ]] && python3 -c "import json; json.load(open('$json_file'))" 2>/dev/null; then
        printf "${_GREEN}  [PASS]${_NC} openclaw.json is valid JSON\n"
        pass=$((pass + 1))
    else
        printf "${_RED}  [FAIL]${_NC} openclaw.json is missing or invalid JSON\n"
        fail_count=$((fail_count + 1))
    fi

    # 2. Gateway token present in config
    local json_token
    json_token=$(read_json_token)
    if [[ -n "$json_token" ]]; then
        printf "${_GREEN}  [PASS]${_NC} Gateway token present in openclaw.json\n"
        pass=$((pass + 1))
    else
        printf "${_RED}  [FAIL]${_NC} No gateway token found in openclaw.json\n"
        fail_count=$((fail_count + 1))
    fi

    # 3. Token synced between openclaw.json and .env
    if [[ -n "$json_token" && -f "$env_file" ]]; then
        local env_token
        env_token=$(grep '^OPENCLAW_GATEWAY_TOKEN=' "$env_file" | cut -d= -f2-)
        if [[ "$json_token" == "$env_token" ]]; then
            printf "${_GREEN}  [PASS]${_NC} Token in sync between openclaw.json and .env\n"
            pass=$((pass + 1))
        else
            printf "${_RED}  [FAIL]${_NC} Token mismatch between openclaw.json and .env\n"
            fail_count=$((fail_count + 1))
        fi
    fi

    # 4. Gateway responding (may be restarting after token change)
    printf "${_CYAN}  [..]${_NC} Waiting for gateway to be healthy...\r"
    if wait_gateway_healthy 30; then
        printf "${_GREEN}  [PASS]${_NC} Gateway is responding on port $GATEWAY_PORT\n"
        pass=$((pass + 1))
    else
        printf "${_RED}  [FAIL]${_NC} Gateway not responding on port $GATEWAY_PORT after 30s\n"
        fail_count=$((fail_count + 1))
    fi

    # 5. Poseidon responding (optional — warn only)
    if curl -sf -o /dev/null --max-time 2 "http://localhost:${POSEIDON_PORT}"; then
        printf "${_GREEN}  [PASS]${_NC} Poseidon is responding on port $POSEIDON_PORT\n"
        pass=$((pass + 1))
    else
        printf "${_YELLOW}  [WARN]${_NC} Poseidon not responding on port $POSEIDON_PORT\n"
        warn_count=$((warn_count + 1))
    fi

    # 6. Summary
    printf "\n${_CYAN}── Summary ──${_NC}\n"
    printf "  ${_GREEN}$pass passed${_NC}"
    if [[ $warn_count -gt 0 ]]; then
        printf ", ${_YELLOW}$warn_count warning(s)${_NC}"
    fi
    if [[ $fail_count -gt 0 ]]; then
        printf ", ${_RED}$fail_count failed${_NC}"
    fi
    printf "\n"

    # Hint about backup if validation failed
    if [[ $fail_count -gt 0 && -f "${json_file}.bak" ]]; then
        log_warn "A backup of your previous config is at: ${json_file}.bak"
        log_warn "Restore with: cp '${json_file}.bak' '$json_file'"
    fi

    # Next steps
    if [[ $fail_count -eq 0 ]]; then
        printf "\n${_GREEN}Setup complete!${_NC} Next steps:\n"
        printf "  mustangclaw dashboard   Open the web dashboard\n"
        printf "  mustangclaw tui         Launch the terminal client\n"
        printf "  mustangclaw poseidon    Open the Poseidon agent dashboard\n"
    fi
    echo ""
}

# ─── Setup (inline) ──────────────────────────────────────────────────────
cmd_setup() {
    # Pre-flight checks
    setup_preflight

    # Use 'onboard' — the Docker-native wizard (official docker-setup.sh uses this).
    # --no-install-daemon prevents the wizard from trying to install a host daemon.
    run_cli onboard --no-install-daemon "$@"

    # After setup, the wizard may have set/changed the gateway token in
    # openclaw.json.  Sync it to .env and restart the gateway so the env-var
    # and config file agree.
    if sync_gateway_token; then
        log_info "Gateway token updated by setup wizard. Syncing..."
        local gw_container
        gw_container=$(get_running_gateway)
        if [[ -n "$gw_container" ]]; then
            log_info "Restarting gateway to apply new token..."
            cd "$PROJECT_ROOT"
            set_compose_files
            docker compose "${COMPOSE_FILES[@]}" up -d openclaw-gateway
        fi
        # Clear device tokens invalidated by the token change
        rm -f "$MUSTANGCLAW_CONFIG_DIR/devices/"* 2>/dev/null || true
        log_info "Gateway restarted with updated token."
    fi

    # Post-setup validation
    setup_validate
}

# ─── TUI (inline) ─────────────────────────────────────────────────────────
cmd_tui() {
    # Clear stale device tokens to avoid mismatch errors on reconnect
    rm -f "$MUSTANGCLAW_CONFIG_DIR/devices/"* 2>/dev/null || true
    run_cli tui "$@"
}

# ─── Token (inline) ────────────────────────────────────────────────────────
cmd_token() {
    local token=""

    # 1. Try openclaw.json (source of truth)
    token=$(read_json_token)

    # 2. Fall back to .env
    if [[ -z "$token" ]]; then
        local env_file="$MUSTANGCLAW_DIR/.env"
        if [[ -f "$env_file" ]]; then
            token=$(grep '^OPENCLAW_GATEWAY_TOKEN=' "$env_file" | cut -d= -f2-)
        fi
    fi

    # 3. Try reading from the running container's environment
    if [[ -z "$token" ]] && command -v docker &>/dev/null; then
        local gw_container
        gw_container=$(get_running_gateway)
        if [[ -n "$gw_container" ]]; then
            token=$(docker exec "$gw_container" printenv OPENCLAW_GATEWAY_TOKEN 2>/dev/null || true)
        fi
    fi

    if [[ -n "$token" ]]; then
        echo "$token"
    else
        log_error "No gateway token found. Run 'mustangclaw run' or 'mustangclaw setup' first."
        exit 1
    fi
}

# ─── Dashboard (inline) ──────────────────────────────────────────────────
cmd_dashboard() {
    # Clear stale device tokens to prevent "device token mismatch" errors.
    rm -f "$MUSTANGCLAW_CONFIG_DIR/devices/"* 2>/dev/null || true

    require_cmd docker
    local gw_container
    gw_container=$(require_running_gateway)

    # Get a fresh dashboard link from the gateway CLI (includes pairing token).
    local dash_url=""
    dash_url=$(docker exec "$gw_container" node dist/index.js dashboard --no-open 2>&1 \
        | grep -oE 'https?://[^ ]+' | head -1 || true)

    # Fall back to constructing the URL with hash-fragment token
    if [[ -z "$dash_url" ]]; then
        local token
        token=$(cmd_token)
        dash_url="http://localhost:${GATEWAY_PORT}/#token=${token}"
    fi

    log_info "Opening dashboard: $dash_url"

    # Auto-approve pending device requests in the background after a short
    # delay — gives the browser time to connect and register its device.
    (
        sleep 4
        # Approve all pending device requests
        local pending
        pending=$(docker exec "$gw_container" node dist/index.js devices list 2>&1 \
            | grep -oE '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}' || true)
        if [[ -n "$pending" ]]; then
            while IFS= read -r req_id; do
                docker exec "$gw_container" node dist/index.js devices approve "$req_id" >/dev/null 2>&1 || true
            done <<< "$pending"
            log_info "Auto-approved pending device(s)."
        fi
    ) &

    open_url "$dash_url"

    log_info "Waiting a few seconds to auto-approve browser device pairing..."
    wait
}

# ─── Poseidon (inline) ─────────────────────────────────────────────────────
cmd_poseidon() {
    require_cmd docker
    require_running_gateway >/dev/null

    local url="http://localhost:${POSEIDON_PORT}"
    log_info "Opening Poseidon: $url"
    open_url "$url"
}

# ─── Status (inline) ───────────────────────────────────────────────────────
cmd_status() {
    local do_health=false
    for arg in "$@"; do
        case "$arg" in
            --health) do_health=true ;;
        esac
    done

    printf "${_CYAN}── Local Container ──${_NC}\n"
    if command -v docker &>/dev/null; then
        local running
        running=$(docker ps --filter "name=^mustangclaw$" --format '{{.Names}}  {{.Status}}  {{.Ports}}' 2>/dev/null || true)
        if [[ -n "$running" ]]; then
            printf "${_GREEN}Running${_NC}  %s\n" "$running"

            # Application-level health check
            if [[ "$do_health" == "true" ]]; then
                printf "\n${_CYAN}── Gateway Health ──${_NC}\n"
                local token
                token=$(read_json_token)
                if [[ -z "$token" ]]; then
                    local env_file="$MUSTANGCLAW_DIR/.env"
                    [[ -f "$env_file" ]] && token=$(grep '^OPENCLAW_GATEWAY_TOKEN=' "$env_file" | cut -d= -f2-)
                fi
                local health_output
                if health_output=$(docker exec mustangclaw node dist/index.js health --token "$token" 2>&1); then
                    printf "${_GREEN}Healthy${_NC}  %s\n" "$health_output"
                else
                    printf "${_RED}Unhealthy${_NC}  %s\n" "$health_output"
                fi
            fi
        else
            printf "${_YELLOW}Not running${_NC}\n"
            if [[ "$do_health" == "true" ]]; then
                printf "${_YELLOW}Skipping health check — container not running${_NC}\n"
            fi
        fi
    else
        printf "${_YELLOW}docker not found${_NC}\n"
    fi

    echo ""
    printf "${_CYAN}── Remote Droplet ──${_NC}\n"
    if command -v doctl &>/dev/null; then
        local droplet
        droplet=$(doctl compute droplet list --tag-name "$DO_TAG" \
            --format Name,PublicIPv4,Status,Memory --no-header 2>/dev/null || true)
        if [[ -n "$droplet" ]]; then
            printf "${_GREEN}Found${_NC}  %s\n" "$droplet"
        else
            printf "${_YELLOW}No droplet with tag '%s'${_NC}\n" "$DO_TAG"
        fi
    else
        printf "${_YELLOW}doctl not installed — skipping remote check${_NC}\n"
    fi
}

# ─── Dispatch ──────────────────────────────────────────────────────────────
COMMAND="${1:-help}"
shift 2>/dev/null || true

case "$COMMAND" in
    init)    exec "$MUSTANGCLAW_ROOT/scripts/init.sh"        "$@" ;;
    build)   exec "$MUSTANGCLAW_ROOT/scripts/build.sh"       "$@" ;;
    run)     exec "$MUSTANGCLAW_ROOT/scripts/run-local.sh"    "$@" ;;
    tui)     cmd_tui "$@" ;;
    setup)   cmd_setup "$@" ;;
    deploy)  exec "$MUSTANGCLAW_ROOT/scripts/deploy-do.sh"    "$@" ;;
    destroy) exec "$MUSTANGCLAW_ROOT/scripts/destroy-do.sh"   "$@" ;;
    sync)    exec "$MUSTANGCLAW_ROOT/scripts/sync-config.sh"  "$@" ;;
    upgrade) exec "$MUSTANGCLAW_ROOT/scripts/upgrade.sh"      "$@" ;;
    ssh)     exec "$MUSTANGCLAW_ROOT/scripts/ssh-do.sh"       "$@" ;;
    sandbox) exec "$MUSTANGCLAW_ROOT/scripts/sandbox-build.sh" "$@" ;;
    save)    exec "$MUSTANGCLAW_ROOT/scripts/save.sh"          "$@" ;;
    load)    exec "$MUSTANGCLAW_ROOT/scripts/load.sh"          "$@" ;;
    restart)
        log_info "Restarting gateway..."
        docker restart mustangclaw
        log_info "Gateway restarted."
        ;;
    token)     cmd_token ;;
    dashboard) cmd_dashboard ;;
    poseidon)  cmd_poseidon ;;
    logs)
        TAIL_LINES=100
        for arg in "$@"; do
            case "$arg" in
                --lines) shift; TAIL_LINES="${1:-100}" ;;
                --lines=*) TAIL_LINES="${arg#--lines=}" ;;
            esac
        done
        exec docker logs mustangclaw --tail "$TAIL_LINES" -f
        ;;
    docker)
        gw_container=$(require_running_gateway)
        # Install 'openclaw' wrapper so the command works inside the shell
        docker exec --user root "$gw_container" sh -c \
            'printf "#!/bin/sh\ncd /app && exec node dist/index.js \"\$@\"\n" > /usr/local/bin/openclaw && chmod +x /usr/local/bin/openclaw'
        exec docker exec -it "$gw_container" /bin/sh
        ;;
    exec)
        gw_container=$(require_running_gateway)
        exec docker exec -it "$gw_container" node dist/index.js "$@"
        ;;
    audit)   exec "$MUSTANGCLAW_ROOT/scripts/audit.sh"         "$@" ;;
    rotate-tokens) exec "$MUSTANGCLAW_ROOT/scripts/rotate-tokens.sh" "$@" ;;
    status)  cmd_status "$@" ;;
    help|--help|-h) usage ;;
    *)
        log_error "Unknown command: $COMMAND"
        echo ""
        usage
        ;;
esac
