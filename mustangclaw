#!/usr/bin/env bash
set -euo pipefail

# ─── Resolve repo root ─────────────────────────────────────────────────────
MUSTANGCLAW_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$MUSTANGCLAW_ROOT/scripts/config.sh"

# ─── Help ───────────────────────────────────────────────────────────────────
usage() {
    cat <<EOF
Usage: mustangclaw <command> [options]

Commands:
  init      Configure MustangClaw (interactive wizard) [--reset]
  build     Clone repo & build Docker image          [--no-pull] [--browser] [--apt PKG]
  run       Run gateway locally                      [--rebuild] [--logs] [--stop]
  tui       Launch interactive TUI client
  setup     Run OpenClaw interactive setup wizard
  deploy    Create & provision DO droplet             [--dry-run] [--force]
  destroy   Tear down DO droplet                      [--force]
  sync      Sync ~/.mustangclaw config               [--target local|remote] [--ip IP] [--dry-run]
  upgrade   Upgrade MustangClaw in-place             [--target local|remote] [--ip IP] [--rollback]
  ssh       SSH into droplet                          [--tunnel] [--ip IP]
  sandbox   Build sandbox images for agent isolation    [--browser] [--common] [--all]
  token     Show the current gateway token
  dashboard Open OpenClaw Control in the browser (with token)
  docker    Open a shell inside the gateway container
  rotate-tokens  Rotate all device tokens with full scope set (2026.2.19 fix)
  status    Show local container & remote droplet status  [--health]

Run 'mustangclaw <command> --help' for details on a specific command.
EOF
    exit 0
}

# ─── Docker CLI helper ────────────────────────────────────────────────────
# Run an openclaw CLI command in a container attached to the gateway's network.
# Falls back to the default compose network if the gateway isn't running.
run_cli() {
    require_cmd docker
    cd "$PROJECT_ROOT"
    if [[ ! -f "$MUSTANGCLAW_DIR/.env" ]]; then
        log_error "No .env found. Run 'mustangclaw run' first to start the gateway."
        exit 1
    fi
    source "$MUSTANGCLAW_DIR/.env"

    # Prefer token from openclaw.json (source of truth after 'mustangclaw setup')
    local openclaw_json="$MUSTANGCLAW_CONFIG_DIR/openclaw.json"
    if [[ -f "$openclaw_json" ]]; then
        local json_token
        json_token=$(python3 -c "
import json, sys
try:
    cfg = json.load(open(sys.argv[1]))
    print(cfg.get('gateway',{}).get('auth',{}).get('token',''))
except: pass
" "$openclaw_json" 2>/dev/null || true)
        if [[ -n "$json_token" ]]; then
            OPENCLAW_GATEWAY_TOKEN="$json_token"
        fi
    fi

    local network_flag=()
    local gw_container
    gw_container=$(docker ps --filter "name=^mustangclaw$" --filter "status=running" --format '{{.Names}}' | head -1)
    if [[ -n "$gw_container" ]]; then
        network_flag=(--network "container:$gw_container")
    fi
    docker run --rm -it \
        ${network_flag[@]+"${network_flag[@]}"} \
        -e HOME=/home/node \
        -e TERM=xterm-256color \
        -e OPENCLAW_GATEWAY_TOKEN="${OPENCLAW_GATEWAY_TOKEN}" \
        -v "${OPENCLAW_CONFIG_DIR}:/home/node/.openclaw" \
        -v "${OPENCLAW_WORKSPACE_DIR}:/home/node/.openclaw/workspace" \
        "$MUSTANGCLAW_IMAGE" \
        node dist/index.js "$@"
}

# ─── Sync gateway token from openclaw.json → .env ────────────────────────
# Returns 0 if token was updated, 1 if no change needed.
sync_gateway_token() {
    local openclaw_json="$MUSTANGCLAW_CONFIG_DIR/openclaw.json"
    local env_file="$MUSTANGCLAW_DIR/.env"
    [[ -f "$openclaw_json" && -f "$env_file" ]] || return 1

    local new_token old_token
    new_token=$(python3 -c "
import json, sys
try:
    cfg = json.load(open(sys.argv[1]))
    print(cfg.get('gateway',{}).get('auth',{}).get('token',''))
except: pass
" "$openclaw_json" 2>/dev/null || true)
    old_token=$(grep '^OPENCLAW_GATEWAY_TOKEN=' "$env_file" | cut -d= -f2-)
    [[ -n "$new_token" && "$new_token" != "$old_token" ]] || return 1

    # Update .env with the token from openclaw.json
    local tmpfile
    tmpfile=$(mktemp)
    awk -v tok="$new_token" \
        '/^OPENCLAW_GATEWAY_TOKEN=/{$0="OPENCLAW_GATEWAY_TOKEN="tok}{print}' \
        "$env_file" > "$tmpfile" && mv "$tmpfile" "$env_file"
    return 0
}

# ─── Setup (inline) ──────────────────────────────────────────────────────
cmd_setup() {
    # Use 'onboard' — the Docker-native wizard (official docker-setup.sh uses this).
    # --no-install-daemon prevents the wizard from trying to install a host daemon.
    run_cli onboard --no-install-daemon "$@"

    # After setup, the wizard may have set/changed the gateway token in
    # openclaw.json.  Sync it to .env and restart the gateway so the env-var
    # and config file agree.
    if sync_gateway_token; then
        log_info "Gateway token updated by setup wizard. Syncing..."
        local gw_container
        gw_container=$(docker ps --filter "name=^mustangclaw$" --filter "status=running" \
            --format '{{.Names}}' | head -1)
        if [[ -n "$gw_container" ]]; then
            log_info "Restarting gateway to apply new token..."
            cd "$PROJECT_ROOT"
            docker compose -f "$MUSTANGCLAW_DIR/docker-compose.yml" \
                -f "$MUSTANGCLAW_DIR/docker-compose.override.yml" up -d openclaw-gateway
        fi
        # Clear device tokens invalidated by the token change
        rm -f "$MUSTANGCLAW_CONFIG_DIR/devices/"* 2>/dev/null || true
        log_info "Gateway restarted with updated token."
    fi
}

# ─── TUI (inline) ─────────────────────────────────────────────────────────
cmd_tui() {
    # Clear stale device tokens to avoid mismatch errors on reconnect
    rm -f "$MUSTANGCLAW_CONFIG_DIR/devices/"* 2>/dev/null || true
    run_cli tui "$@"
}

# ─── Token (inline) ────────────────────────────────────────────────────────
cmd_token() {
    local token=""

    # 1. Try openclaw.json (source of truth)
    local openclaw_json="$MUSTANGCLAW_CONFIG_DIR/openclaw.json"
    if [[ -f "$openclaw_json" ]]; then
        token=$(python3 -c "
import json, sys
try:
    cfg = json.load(open(sys.argv[1]))
    print(cfg.get('gateway',{}).get('auth',{}).get('token',''))
except: pass
" "$openclaw_json" 2>/dev/null || true)
    fi

    # 2. Fall back to .env
    if [[ -z "$token" ]]; then
        local env_file="$MUSTANGCLAW_DIR/.env"
        if [[ -f "$env_file" ]]; then
            token=$(grep '^OPENCLAW_GATEWAY_TOKEN=' "$env_file" | cut -d= -f2-)
        fi
    fi

    # 3. Try reading from the running container's environment
    if [[ -z "$token" ]] && command -v docker &>/dev/null; then
        local gw_container
        gw_container=$(docker ps --filter "name=^mustangclaw$" --filter "status=running" --format '{{.Names}}' | head -1)
        if [[ -n "$gw_container" ]]; then
            token=$(docker exec "$gw_container" printenv OPENCLAW_GATEWAY_TOKEN 2>/dev/null || true)
        fi
    fi

    if [[ -n "$token" ]]; then
        echo "$token"
    else
        log_error "No gateway token found. Run 'mustangclaw run' or 'mustangclaw setup' first."
        exit 1
    fi
}

# ─── Dashboard (inline) ──────────────────────────────────────────────────
cmd_dashboard() {
    # Clear stale device tokens to prevent "device token mismatch" errors.
    rm -f "$MUSTANGCLAW_CONFIG_DIR/devices/"* 2>/dev/null || true

    require_cmd docker

    local gw_container
    gw_container=$(docker ps --filter "name=^mustangclaw$" --filter "status=running" --format '{{.Names}}' | head -1)
    if [[ -z "$gw_container" ]]; then
        log_error "Gateway container is not running. Start it with 'mustangclaw run'."
        exit 1
    fi

    # Get a fresh dashboard link from the gateway CLI (includes pairing token).
    local dash_url=""
    dash_url=$(docker exec "$gw_container" node dist/index.js dashboard --no-open 2>&1 \
        | grep -oE 'https?://[^ ]+' | head -1 || true)

    # Fall back to constructing the URL with hash-fragment token
    if [[ -z "$dash_url" ]]; then
        local token
        token=$(cmd_token)
        dash_url="http://localhost:${GATEWAY_PORT}/#token=${token}"
    fi

    log_info "Opening dashboard: $dash_url"

    # Auto-approve pending device requests in the background after a short
    # delay — gives the browser time to connect and register its device.
    (
        sleep 4
        # Approve all pending device requests
        local pending
        pending=$(docker exec "$gw_container" node dist/index.js devices list 2>&1 \
            | grep -oE '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}' || true)
        if [[ -n "$pending" ]]; then
            while IFS= read -r req_id; do
                docker exec "$gw_container" node dist/index.js devices approve "$req_id" >/dev/null 2>&1 || true
            done <<< "$pending"
            log_info "Auto-approved pending device(s)."
        fi
    ) &

    # macOS
    if command -v open &>/dev/null; then
        open "$dash_url"
    # Linux (xdg)
    elif command -v xdg-open &>/dev/null; then
        xdg-open "$dash_url"
    # WSL
    elif command -v wslview &>/dev/null; then
        wslview "$dash_url"
    else
        log_warn "Could not detect a browser opener. Open this URL manually:"
        echo "$dash_url"
    fi

    log_info "Waiting a few seconds to auto-approve browser device pairing..."
    wait
}

# ─── Status (inline) ───────────────────────────────────────────────────────
cmd_status() {
    local do_health=false
    for arg in "$@"; do
        case "$arg" in
            --health) do_health=true ;;
        esac
    done

    printf "${_CYAN}── Local Container ──${_NC}\n"
    if command -v docker &>/dev/null; then
        local running
        running=$(docker ps --filter "name=^mustangclaw$" --format '{{.Names}}  {{.Status}}  {{.Ports}}' 2>/dev/null || true)
        if [[ -n "$running" ]]; then
            printf "${_GREEN}Running${_NC}  %s\n" "$running"

            # Application-level health check
            if [[ "$do_health" == "true" ]]; then
                printf "\n${_CYAN}── Gateway Health ──${_NC}\n"
                local env_file="$MUSTANGCLAW_DIR/.env"
                local token=""
                if [[ -f "$env_file" ]]; then
                    token=$(grep '^OPENCLAW_GATEWAY_TOKEN=' "$env_file" | cut -d= -f2-)
                fi
                local health_output
                if health_output=$(docker exec mustangclaw node dist/index.js health --token "$token" 2>&1); then
                    printf "${_GREEN}Healthy${_NC}  %s\n" "$health_output"
                else
                    printf "${_RED}Unhealthy${_NC}  %s\n" "$health_output"
                fi
            fi
        else
            printf "${_YELLOW}Not running${_NC}\n"
            if [[ "$do_health" == "true" ]]; then
                printf "${_YELLOW}Skipping health check — container not running${_NC}\n"
            fi
        fi
    else
        printf "${_YELLOW}docker not found${_NC}\n"
    fi

    echo ""
    printf "${_CYAN}── Remote Droplet ──${_NC}\n"
    if command -v doctl &>/dev/null; then
        local droplet
        droplet=$(doctl compute droplet list --tag-name "$DO_TAG" \
            --format Name,PublicIPv4,Status,Memory --no-header 2>/dev/null || true)
        if [[ -n "$droplet" ]]; then
            printf "${_GREEN}Found${_NC}  %s\n" "$droplet"
        else
            printf "${_YELLOW}No droplet with tag '%s'${_NC}\n" "$DO_TAG"
        fi
    else
        printf "${_YELLOW}doctl not installed — skipping remote check${_NC}\n"
    fi
}

# ─── Dispatch ──────────────────────────────────────────────────────────────
COMMAND="${1:-help}"
shift 2>/dev/null || true

case "$COMMAND" in
    init)    exec "$MUSTANGCLAW_ROOT/scripts/init.sh"        "$@" ;;
    build)   exec "$MUSTANGCLAW_ROOT/scripts/build.sh"       "$@" ;;
    run)     exec "$MUSTANGCLAW_ROOT/scripts/run-local.sh"    "$@" ;;
    tui)     cmd_tui "$@" ;;
    setup)   cmd_setup "$@" ;;
    deploy)  exec "$MUSTANGCLAW_ROOT/scripts/deploy-do.sh"    "$@" ;;
    destroy) exec "$MUSTANGCLAW_ROOT/scripts/destroy-do.sh"   "$@" ;;
    sync)    exec "$MUSTANGCLAW_ROOT/scripts/sync-config.sh"  "$@" ;;
    upgrade) exec "$MUSTANGCLAW_ROOT/scripts/upgrade.sh"      "$@" ;;
    ssh)     exec "$MUSTANGCLAW_ROOT/scripts/ssh-do.sh"       "$@" ;;
    sandbox) exec "$MUSTANGCLAW_ROOT/scripts/sandbox-build.sh" "$@" ;;
    token)     cmd_token ;;
    dashboard) cmd_dashboard ;;
    docker)
        gw_container=$(docker ps --filter "name=^mustangclaw$" --filter "status=running" --format '{{.Names}}' | head -1)
        if [[ -z "$gw_container" ]]; then
            log_error "Gateway container is not running. Start it with 'mustangclaw run'."
            exit 1
        fi
        # Install 'openclaw' wrapper so the command works inside the shell
        docker exec --user root "$gw_container" sh -c \
            'printf "#!/bin/sh\ncd /app && exec node dist/index.js \"\$@\"\n" > /usr/local/bin/openclaw && chmod +x /usr/local/bin/openclaw'
        exec docker exec -it "$gw_container" /bin/sh
        ;;
    rotate-tokens) exec "$MUSTANGCLAW_ROOT/scripts/rotate-tokens.sh" "$@" ;;
    status)  cmd_status "$@" ;;
    help|--help|-h) usage ;;
    *)
        log_error "Unknown command: $COMMAND"
        echo ""
        usage
        ;;
esac
